/*************************************************************************************/
/*         单链表基本操作函数
/*------------------------------------------------------------------------------------
/*
/*
/* 创建时间：2016年12月27日
/************************************************************************************/

#include <stdio.h>
#include <malloc.h>

typedef char ElemType;

//-----------------------------------------------------------------------------------
// 定义单链表结点类型
//-----------------------------------------------------------------------------------
typedef struct LNode
{
    ElemType data;
    struct LNode *next;        /*指向后继结点*/
} LinkList;

//===================================================================================
//   初始化单链表
//===================================================================================
void InitList(LinkList *&L)
{
    L=(LinkList *)malloc(sizeof(LinkList));      /*创建头结点*/
    L->next=NULL;
}

//===================================================================================
// 头插法建立单链表
// L--> "+" -->d-->c-->b-->a [逆序]
//===================================================================================
void CreateListF(LinkList *&L, ElemType a[], int n)
{
    int i;
    LinkList *s;
    L=(LinkList *)malloc(sizeof(LinkList));      /*创建头结点*/
    L->next=NULL;

    for(i=0; i<n; i++)
    {
        s=(LinkList *)malloc(sizeof(LinkList));  /*创建新结点*/
        s->data=a[i];
        s->next=L->next;                         /*将*s插在原开始结点之前,头结点之后*/
        L->next=s;
    }
}

//===================================================================================
// 尾插法建立单链表
// L-->a-->b-->c-->d-->"+" [顺序]
//===================================================================================
void CreateListR(LinkList *&L, ElemType a[], int n)
{
    int i;
    LinkList *s,*r;
    L=(LinkList *)malloc(sizeof(LinkList));      /*创建头结点*/
    L->next=NULL;
    r=L;                                         /*r始终指向终端结点,开始时指向头结点*/

    for (i=0;i<n;i++)
    {    
        s=(LinkList *)malloc(sizeof(LinkList));  /*创建新结点*/
        s->data=a[i];
        r->next=s;                               /*将*s插入*r之后*/
        r=s;
    }
    r->next=NULL;                                /*终端结点next域置为NULL*/
}

//===================================================================================
//  销毁单链表
//===================================================================================
void DestroyList(LinkList *&L)
{
    LinkList *p=L,*q=p->next;
    while (q!=NULL)
    {
        free(p);
        p=q;
        q=p->next;
    }
    free(p);    /*此时q为NULL, p指向尾结点,释放它*/
}

//===================================================================================
// 判断单链表是否为空
//===================================================================================
int ListEmpty(LinkList *L)
{
    return (L->next==NULL);
}

//===================================================================================
// 求单链表的长度
//===================================================================================
int ListLength(LinkList *L)
{
    int i=0;
    LinkList *p=L;
    while (p->next!=NULL)
    {
        i++;
        p=p->next;
    }
    return(i);
}

//===================================================================================
// 展示单链表的元素
//===================================================================================
void DispList(LinkList *L)
{
    LinkList *p=L->next;
    while (p!=NULL)
    {
        printf(" %c ",p->data);
        p=p->next;
    }
    printf("\n");
}

//===================================================================================
// 获取单链表中指定位置的元素值
//===================================================================================
int GetElem(LinkList *L, int i, ElemType &e)
{
    int j=0;
    LinkList *p=L;
    while (j<i && p!=NULL)  //节点存在
    {
        j++;
        p=p->next;
    }
    if (p==NULL)            /*不存在第i个数据结点*/
        return 0;
    else                    /*存在第i个数据结点*/
    {
        e=p->data;
        return 1;
    }
}

//===================================================================================
// 获取单链表中某个元素的位置
//===================================================================================
int LocateElem(LinkList *L, ElemType e)
{
    int n=1;
    LinkList *p=L->next;
    while (p!=NULL && p->data!=e)
    {
        p=p->next;
        n++;
    }
    if (p==NULL)
        return(0);
    else
        return(n);
}

//===================================================================================
//   单链表插入新的元素
//===================================================================================
int ListInsert(LinkList *&L, int i, ElemType e)
{
    int j=0;
    LinkList *p=L,*s;
    while (j<i-1 && p!=NULL) /*查找第i-1个结点*/
    {
        j++;
        p=p->next;
    }
    if (p==NULL)    /*未找到位序为i-1的结点*/
        return 0;
    else            /*找到位序为i-1的结点*p*/
    {
        s=(LinkList *)malloc(sizeof(LinkList)); /*创建新结点*s*/
        s->data=e;
        s->next=p->next;                        /*将*s插入到*p之后*/
        p->next=s;
        return 1;
    }
}

//===================================================================================
// 单链表删除元素
//===================================================================================
int ListDelete(LinkList *&L,int i,ElemType &e)
{
    int j=0;
    LinkList *p=L,*q;
    while (j<i-1 && p!=NULL)    /*查找第i-1个结点*/
    {
        j++;
        p=p->next;
    }
    if (p==NULL)                /*未找到位序为i-1的结点*/
        return 0;
    else                        /*找到位序为i-1的结点*p*/
    {
        q=p->next;              /*q指向要删除的结点*/
        if (q==NULL) 
            return 0;           /*若不存在第i个结点,返回0*/
        p->next=q->next;        /*从单链表中删除*q结点*/
        free(q);                /*释放*q结点*/
        return 1;
    }
}

//===================================================================================
// 单链表分割
//===================================================================================
void split(LinkList *&L, LinkList *&L1, LinkList *&L2)
{
    LinkList *p=L->next,*q,*r1;
    L1=L;                      /*L1利用原来L的头结点*/
    L=NULL;                    /*L置为空*/
    r1=L1;                     /*r1始终指向L1的尾结点*/
    L2=(LinkList *)malloc(sizeof(LinkList)); /*创建L2的头结点*/
    L2->next=NULL;
    while (p!=NULL)
    {
        q=p->next;            /*q指向*p的后续结点*/
        r1->next=p;
        r1=p;                /*采用尾插法将*p插入L1中*/
        p=q->next;
        q->next=L2->next;    
        L2->next=q;            /*采用头插法将*p插入L2中*/
    }
    r1->next=NULL;            /*尾结点next置空*/
}

//===================================================================================
// main函数
//===================================================================================
void main()
{
    LinkList *L,*L1,*L2;
    int n=10;
    char a[]={'a','b','c','d','e','f','g','h','i','j'};
    InitList(L);
    InitList(L1);
    InitList(L2);
    CreateListR(L,a,n);
    printf("L:");DispList(L);
    printf("L->L1,L2\n");
    split(L,L1,L2);
    printf("L1:");DispList(L1);
    printf("L2:");DispList(L2);
    DestroyList(L1);
    DestroyList(L2);
}
